<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Technical Interview [자료구조] | 현수쓰</title><meta name="description" content="Technical Interview [자료구조]"><meta name="keywords" content="취뽀가잣!"><meta name="author" content="현수쓰"><meta name="copyright" content="현수쓰"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://khs9628.github.io/2019/09/06/CS4/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Technical Interview [자료구조]"><meta name="twitter:description" content="Technical Interview [자료구조]"><meta name="twitter:image" content="https://khs9628.github.io/img/운영체제.PNG"><meta property="og:type" content="article"><meta property="og:title" content="Technical Interview [자료구조]"><meta property="og:url" content="https://khs9628.github.io/2019/09/06/CS4/"><meta property="og:site_name" content="현수쓰"><meta property="og:description" content="Technical Interview [자료구조]"><meta property="og:image" content="https://khs9628.github.io/img/운영체제.PNG"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Technical Interview [면접후기]" href="https://khs9628.github.io/2019/09/06/CS5/"><link rel="next" title="Technical Interview [네트워크]" href="https://khs9628.github.io/2019/09/06/CS3/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#자료구조"><span class="toc-number">1.</span> <span class="toc-text">자료구조</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-vs-LinkedList"><span class="toc-number">1.1.</span> <span class="toc-text">Array vs LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack-and-Queue"><span class="toc-number">1.1.1.</span> <span class="toc-text">Stack and Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tree"><span class="toc-number">1.1.2.</span> <span class="toc-text">Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Heap"><span class="toc-number">1.1.3.</span> <span class="toc-text">Binary Heap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Red-Black-Tree"><span class="toc-number">1.1.4.</span> <span class="toc-text">Red Black Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashTable"><span class="toc-number">1.1.5.</span> <span class="toc-text">HashTable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-function"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">hash function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resolve-Conflict"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">Resolve Conflict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#데이터가-적다는-것은-얼마나-적다는-것을-의미하는가"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">데이터가 적다는 것은 얼마나 적다는 것을 의미하는가?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Open-Address-vs-Separate-Chaining"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">Open Address vs Separate Chaining</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#보조-해시-함수"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">보조 해시 함수</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#해시-버킷-동적-확장-Resize"><span class="toc-number">1.1.5.6.</span> <span class="toc-text">해시 버킷 동적 확장(Resize)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graph"><span class="toc-number">1.1.6.</span> <span class="toc-text">Graph</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/운영체제.PNG)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">현수쓰</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><div class="menu_mask"></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item text-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item text-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item text-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">11</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> PortPolio</span></a></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Technical Interview [자료구조]</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-09-06<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-10-01</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/면접준비/">면접준비</a></span></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p><a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner" rel="external nofollow noopener noreferrer" target="_blank">참고링크</a></p>
<h1 id="자료구조"><a href="#자료구조" class="headerlink" title="자료구조"></a>자료구조</h1><h2 id="Array-vs-LinkedList"><a href="#Array-vs-LinkedList" class="headerlink" title="Array vs LinkedList"></a>Array vs LinkedList</h2><p><code>Array</code><br>가장 기본적인 자료구조인 Array 자료구조는, 논리적 저장 순서와 물리적 저장 순서가 일치한다.<br>따라서 인덱스(index)로 해당 원소(element)에 접근할 수 있다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 Big-O(1)에 해당 원소로 접근할 수 있다. 즉 random access 가 가능하다는 장점이 있는 것이다.</p>
<p>하지만 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤(O(1)), 또 한 가지의 작업을 추가적으로 해줘야 하기 때문에, 시간이 더 걸린다.<br>만약 배열의 원소 중 어느 <code>원소를 삭제</code>했다고 했을 때, 배열의 연속적인 특징이 깨지게 된다. 즉 빈 공간이 생기는 것이다.<br>따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift해줘야 하는 비용(cost)이 발생하고 이 경우의 시간 복잡도는 <code>O(n)</code>가 된다.<br>그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 time complexity 의 worst case 는 O(n)이 된다.</p>
<p><code>삽입</code>의 경우도 마찬가지이다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1 씩 shift 해줘야 하므로 이 경우도 <code>O(n)</code>의 시간을 요구하게 된다.</p>
<p><code>LinkedList</code><br>이 부분에 대한 문제점을 해결하기 위한 자료구조가 linked list 이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 O(1) 만에 해결할 수 있는 것이다.</p>
<p>하지만 LinkedList 역시 한 가지 문제가 있다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search 과정에 있어서 첫번째 원소부터 다 확인해봐야 한다는 것이다. Array 와는 달리 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문이다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지이다. 이 과정 때문에, 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 O(n)의 시간이 추가적으로 발생하게 된다.</p>
<p>결국 linked list 자료구조는 search 에도 O(n)의 time complexity 를 갖고, 삽입, 삭제에 대해서도 O(n)의 time complexity 를 갖는다. 그렇다고 해서 아주 쓸모없는 자료구조는 아니기에, 우리가 학습하는 것이다. 이 Linked List 는 Tree 구조의 근간이 되는 자료구조이며, Tree 에서 사용되었을 때 그 유용성이 드러난다.</p>
<h3 id="Stack-and-Queue"><a href="#Stack-and-Queue" class="headerlink" title="Stack and Queue"></a>Stack and Queue</h3><p><code>Stack</code><br>선형 자료구조의 일종으로 <code>Last In First Out (LIFO)</code>.<br>즉, 나중에 들어간 원소가 먼저 나온다. 이것은 Stack 의 가장 큰 특징이다.<br>차곡차곡 쌓이는 구조로 먼저 Stack 에 들어가게 된 원소는 맨 바닥에 깔리게 된다.<br>그렇기 때문에 늦게 들어간 녀석들은 그 위에 쌓이게 되고 호출 시 가장 위에 있는 녀석이 호출되는 구조이다.</p>
<p><code>Queue</code><br>선형 자료구조의 일종으로 <code>First In First Out (FIFO)</code>.<br>즉, 먼저 들어간 놈이 먼저 나온다. Stack 과는 반대로 먼저 들어간 놈이 맨 앞에서 대기하고 있다가 먼저 나오게 되는 구조이다.<br>참고로 Java Collection 에서 Queue 는 인터페이스이다.<br>이를 구현하고 있는 Priority queue등을 사용할 수 있다.</p>
<h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><p><code>Tree</code>는 스택이나 큐와 같은 선형 구조가 아닌 <code>비선형 자료구조</code>이다.<br>트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다.<br>이 트리라는 자료구조는 표현에 집중한다. 무엇인가를 저장하고 꺼내야 한다는 사고에서 벗어나 트리라는 자료구조를 바라보자.</p>
<p>트리를 구성하고 있는 구성요소들(용어)</p>
<ul>
<li>Node (노드) : 트리를 구성하고 있는 각각의 요소를 의미한다.</li>
<li>Edge (간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.</li>
<li>Root Node (루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미한다.</li>
<li>Terminal Node ( = leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.</li>
<li>Internal Node (내부노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.</li>
</ul>
<p><code>Binary Tree (이진 트리)</code><br>루트 노드를 중심으로 두 개의 서브 트리(큰 트리에 속하는 작은 트리)로 나뉘어 진다.<br>또한 나뉘어진 두 서브 트리도 모두 이진 트리어야 한다. 한 가지 덧붙이자면 공집합도 이진 트리로 포함시켜야 한다.<br>자연스럽게 노드가 하나 뿐인 것도 이진 트리 정의에 만족하게 된다.</p>
<p>트리에서는 각 층별로 숫자를 매겨서 이를 트리의 <code>Level(레벨)</code>이라고 한다.<br>레벨의 값은 0 부터 시작하고 따라서 루트 노트의 레벨은 0 이다. 그리고 트리의 최고 레벨을 가리켜 해당 트리의 <code>height(높이)</code>라고 한다.</p>
<p><code>Full Binary Tree (포화 이진 트리), Complete Binary Tree (완전 이진 트리)</code><br>모든 레벨이 꽉 찬 이진 트리를 가리켜 포화 이진 트리라고 한다.<br>위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리켜 완전 이진 트리라고 한다.<br>배열로 구성된 Full Binary Tree와 Complete binary tree는 노드의 개수가 n 개 일 때, i 번째 노드에 대해서 parent(i) = i/2 , left_child(i) = 2i , right_child(i) = 2i + 1 의 index 값을 갖는다.</p>
<p><code>BST(Binary Search Tree)</code><br>효율적인 탐색을 위해서는 어떻게 찾을까만 고민해서는 안된다. 그보다는 효율적인 탐색을 위한 저장방법이 무엇일까를 고민해야 한다. 이진 탐색 트리는 이진 트리의 일종이다. 단 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.</p>
<ol>
<li>이진 탐색 트리의 노드에 저장된 키는 유일하다.</li>
<li>루트 노드의 키가 왼쪽 서브 트리를 구성하는 어떠한 노드의 키보다 크다.</li>
<li>루트 노드의 키가 오른쪽 서브 트리를 구성하는 어떠한 노드의 키보다 작다.</li>
<li>왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.</li>
</ol>
<p>이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖는다.<br>사실 정확히 말하면 O(h)라고 표현하는 것이 맞다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두 배씩 증가하기 때문이다.<br>하지만 이러한 이진 탐색 트리는 <code>Skewed Tree(편향 트리)</code>가 될 수 있다.<br>저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문이다.<br>이럴 경우 성능에 영향을 미치게 되며, 탐색의 Worst Case 가 되고 시간 복잡도는 <code>O(n)</code>이 된다.</p>
<p>배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다.<br>균형을 잡기 위한 트리 구조의 재조정을 <code>Rebalancing</code>이라 한다.<br>이 기법을 구현한 트리에는 여러 종류가 존재하는데 그 중에서 하나가 뒤에서 살펴볼 Red-Black Tree이다.</p>
<h3 id="Binary-Heap"><a href="#Binary-Heap" class="headerlink" title="Binary Heap"></a>Binary Heap</h3><p>자료구조의 일종으로 Tree 의 형식을 하고 있으며, Tree 중에서도 배열에 기반한 Complete Binary Tree이다.<br>배열에 트리의 값들을 넣어줄 때, 0 번째는 건너뛰고 1 번 index 부터 루트노드가 시작된다.<br>이는 노드의 고유번호 값과 배열의 index 를 일치시켜 혼동을 줄이기 위함이다. 힙(Heap)에는 <code>최대힙(max heap)</code>, <code>최소힙(min heap)</code> 두 종류가 있다.</p>
<p><code>Max Heap</code>이란, 각 노드의 값이 해당 children 의 값보다 크거나 같은 complete binary tree를 말한다. ( Min heap 은 그 반대이다.)</p>
<p>Max heap에서는 Root node 에 있는 값이 제일 크므로, 최대값을 찾는데 소요되는 연산의 time complexity 이 O(1)이다. 그리고 complete binary tree이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다. (즉, random access 가 가능하다. Min heap 에서는 최소값을 찾는데 소요되는 연산의 time complexity 가 O(1)이다.)<br>하지만 heap 의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 heap 은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지한다. 이런 경우에는 결국 O(log n)의 시간복잡도로 최대값 또는 최소값에 접근할 수 있게 된다.</p>
<h3 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red Black Tree"></a>Red Black Tree</h3><p><code>RBT(Red-Black Tree)</code>는 BST 를 기반으로하는 트리 형식의 자료구조이다.<br>결론부터 말하자면 Red-Black Tree 에 데이터를 저장하게되면 Search, Insert, Delete 에 O(log n)의 시간 복잡도가 소요된다.<br>동일한 노드의 개수일 때, depth 를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어이다.<br>동일한 노드의 개수일 때, depth 가 최소가 되는 경우는 tree 가 complete binary tree 인 경우이다.</p>
<p>Red-Black Tree 의 정의<br>Red-Black Tree 는 다음의 성질들을 만족하는 BST 이다.</p>
<ul>
<li>각 노드는 Red or Black이라는 색깔을 갖는다.</li>
<li>Root node 의 색깔은 Black이다.</li>
<li>각 leaf node 는 black이다.</li>
<li>어떤 노드의 색깔이 red라면 두 개의 children 의 색깔은 모두 black 이다.</li>
<li>각 노드에 대해서 노드로부터 descendant leaves 까지의 단순 경로는 모두 같은 수의 black nodes 들을 포함하고 있다. 이를 해당 노드의 Black-Height라고 한다.<br>cf) Black-Height: 노드 x 로부터 노드 x 를 포함하지 않은 leaf node 까지의 simple path 상에 있는 black nodes 들의 개수</li>
</ul>
<p>Red-Black Tree 의 특징</p>
<ul>
<li>Binary Search Tree 이므로 BST 의 특징을 모두 갖는다.</li>
<li>Root node 부터 leaf node 까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2 보다 크지 않다. 이러한 상태를 balanced 상태라고 한다.</li>
<li>노드의 child 가 없을 경우 child 를 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL 들을 leaf node 로 간주한다.</li>
<li>RBT 는 BST 의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어진 자료구조이다. 이를 어떻게 해결한 것인가?</li>
</ul>
<p><code>삽입</code><br>우선 BST 의 특성을 유지하면서 노드를 삽입을 한다. 그리고 삽입된 노드의 색깔을 RED 로 지정한다. Red 로 지정하는 이유는 Black-Height 변경을 최소화하기 위함이다. 삽입 결과 RBT 의 특성 위배(violation)시 노드의 색깔을 조정하고, Black-Height 가 위배되었다면 rotation 을 통해 height 를 조정한다. 이러한 과정을 통해 RBT 의 동일한 height 에 존재하는 internal node 들의 Black-height 가 같아지게 되고 최소 경로와 최대 경로의 크기 비율이 2 미만으로 유지된다.</p>
<p><code>삭제</code><br>삭제도 삽입과 마찬가지로 BST 의 특성을 유지하면서 해당 노드를 삭제한다. 삭제될 노드의 child 의 개수에 따라 rotation 방법이 달라지게 된다. 그리고 만약 지워진 노드의 색깔이 Black 이라면 Black-Height 가 1 감소한 경로에 black node 가 1 개 추가되도록 rotation 하고 노드의 색깔을 조정한다. 지워진 노드의 색깔이 red 라면 Violation 이 발생하지 않으므로 RBT 가 그대로 유지된다.</p>
<p>Java Collection 에서 ArrayList 도 내부적으로 RBT 로 이루어져 있고, HashMap 에서의 Separate Chaining에서도 사용된다. 그만큼 효율이 좋고 중요한 자료구조이다.</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다.<br>특정한 값을 Search 하는데 데이터 고유의 인덱스로 접근하게 되므로 average case 에 대하여 Time Complexity 가 <code>O(1)</code>이 되는 것이다.<br>(항상 O(1)이 아니고 average case 에 대해서 O(1)인 것은 collision 때문이다.)<br>하지만 문제는 이 인덱스로 저장되는 key값이 불규칙하다는 것이다.</p>
<p>그래서 특별한 알고리즘을 이용하여 저장할 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다.<br>특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없으므로 <code>연산에서 추가적인 비용이 없도록 만들어진 구조</code>이다.</p>
<h4 id="hash-function"><a href="#hash-function" class="headerlink" title="hash function"></a>hash function</h4><p>‘특별한 알고리즘’이란 것을 통해 고유한 인덱스 값을 설정하는 것이 중요해보인다.<br>위에서 언급한 ‘특별한 알고리즘’을 hash method 또는 해시 함수(hash function)라고 하고 이 메소드에 의해 반환된 데이터의 고유 숫자 값을 <code>hashcode</code>라고 한다. 저장되는 값들의 key 값을 hash function을 통해서 작은 범위의 값들로 바꿔준다.</p>
<p>하지만 어설픈 hash function을 통해서 key 값들을 결정한다면 동일한 값이 도출될 수가 있다.<br>이렇게 되면 동일한 key 값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 것인데 이를 <code>Collision</code> 이라고 한다.<br>Collision : 서로 다른 두 개의 키가 같은 인덱스로 hashing(hash 함수를 통해 계산됨을 의미)되면 같은 곳에 저장할 수 없게 된다.</p>
<p>그렇다면 좋은 hash function는 어떠한 조건들을 갖추고 있어야 하는가?<br>일반적으로 좋은 hash function는 키의 일부분을 참조하여 해쉬 값을 만들지 않고 키 전체를 참조하여 해쉬 값을 만들어 낸다.<br>하지만 좋은 해쉬 함수는 키가 어떤 특성을 가지고 있느냐에 따라 달라지게 된다.</p>
<p>hash function를 무조건 1:1 로 만드는 것보다 Collision 을 최소화하는 방향으로 설계하고 발생하는 Collision 에 대비해 어떻게 대응할 것인가가 더 중요하다. 1:1 대응이 되도록 만드는 것이 거의 불가능하기도 하지만 그런 hash function를 만들어봤자 그건 array 와 다를바 없고 메모리를 너무 차지하게 된다.</p>
<p>Collision 이 많아질 수록 Search 에 필요한 Time Complexity 가 O(1)에서 O(n)에 가까워진다. 어설픈 hash function는 hash 를 hash 답게 사용하지 못하도록 한다. 좋은 hash function를 선택하는 것은 hash table 의 성능 향상에 필수적인 것이다.</p>
<p>따라서 hashing 된 인덱스에 이미 다른 값이 들어 있다면 세 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있는 것이다. 따라서 충돌 해결은 필수이며 그 방법들에 대해 알아보자.</p>
<h4 id="Resolve-Conflict"><a href="#Resolve-Conflict" class="headerlink" title="Resolve Conflict"></a>Resolve Conflict</h4><p>기본적인 두 가지 방법부터 알아보자. 해시 충돌을 해결하기 위한 다양한 자료가 있지만, 다음 두 가지 방법을 응용한 방법들이기 때문이다.</p>
<ol>
<li>Open Address 방식 (개방주소법)<br>해시 충돌이 발생하면, (즉 삽입하려는 해시 버킷이 이미 사용 중인 경우) 다른 해시 버킷에 해당 자료를 삽입하는 방식 이다. 버킷이란 바구니와 같은 개념으로 데이터를 저장하기 위한 공간이라고 생각하면 된다. 다른 해시 버킷이란 어떤 해시 버킷을 말하는 것인가?</li>
</ol>
<p>공개 주소 방식이라고도 불리는 이 알고리즘은 Collision 이 발생하면 데이터를 저장할 장소를 찾아 헤맨다. Worst Case 의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. 이 과정에서도 여러 방법들이 존재하는데, 다음 세 가지에 대해 알아보자.</p>
<ul>
<li>Linear Probing<br>순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다.</li>
<li>Quadratic probing<br>2 차 함수를 이용해 탐색할 위치를 찾는다.</li>
<li>Double hashing probing<br>하나의 해쉬 함수에서 충돌이 발생하면 2 차 해쉬 함수를 이용해 새로운 주소를 할당한다. 위 두 가지 방법에 비해 많은 연산량을 요구하게 된다.</li>
</ul>
<ol start="2">
<li>Separate Chaining 방식 (분리 연결법)<br>일반적으로 Open Addressing 은 Separate Chaining 보다 느리다. Open Addressing 의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면 Separate Chaining 방식의 경우 해시 충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 조정할 수 있다면 Worst Case 에 가까워 지는 빈도를 줄일 수 있다. Java 7 에서는 Separate Chaining 방식을 사용하여 HashMap 을 구현하고 있다. Separate Chaining 방식으로는 두 가지 구현 방식이 존재한다.</li>
</ol>
<ul>
<li><p>연결 리스트를 사용하는 방식(Linked List)<br>각각의 버킷(bucket)들을 연결리스트(Linked List)로 만들어 Collision 이 발생하면 해당 bucket 의 list 에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다. 또 다른 특징으로는, 버킷을 계속해서 사용하는 Open Address 방식에 비해 테이블의 확장을 늦출 수 있다.</p>
</li>
<li><p>Tree 를 사용하는 방식 (Red-Black Tree)<br>기본적인 알고리즘은 Separate Chaining 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식이다. 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 데이터의 개수가 적다면 링크드 리스트를 사용하는 것이 맞다. 트리는 기본적으로 메모리 사용량이 많기 때문이다. 데이터 개수가 적을 때 Worst Case 를 살펴보면 트리와 링크드 리스트의 성능 상 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 링크드 리스트를 사용한다.</p>
</li>
</ul>
<h4 id="데이터가-적다는-것은-얼마나-적다는-것을-의미하는가"><a href="#데이터가-적다는-것은-얼마나-적다는-것을-의미하는가" class="headerlink" title="데이터가 적다는 것은 얼마나 적다는 것을 의미하는가?"></a>데이터가 적다는 것은 얼마나 적다는 것을 의미하는가?</h4><p>앞에서 말했듯이 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 이 키-값 쌍의 개수가 6 개, 8 개를 기준으로 결정한다. 기준이 두 개 인것이 이상하게 느껴질 수 있다. 7 은 어디로 갔는가? 링크드 리스트의 기준과 트리의 기준을 6 과 8 로 잡은 것은 변경하는데 소요되는 비용을 줄이기 위함이다.</p>
<p>한 가지 상황을 가정해보자.<br>해시 버킷에 6 개 의 key-value 쌍이 들어있었다. 그리고 하나의 값이 추가되었다. 만약 기준이 6 과 7 이라면 자료구조를 링크드 리스트에서 트리로 변경해야 한다. 그러다 바로 하나의 값이 삭제된다면 다시 트리에서 링크드 리스트로 자료구조를 변경해야 한다. 각각 자료구조로 넘어가는 기준이 1 이라면 Switching 비용이 너무 많이 필요하게 되는 것이다. 그래서 2 라는 여유를 남겨두고 기준을 잡아준 것이다. 따라서 데이터의 개수가 6 개에서 7 개로 증가했을 때는 링크드 리스트의 자료구조를 취하고 있을 것이고 8 개에서 7 개로 감소했을 때는 트리의 자료구조를 취하고 있을 것이다.</p>
<h4 id="Open-Address-vs-Separate-Chaining"><a href="#Open-Address-vs-Separate-Chaining" class="headerlink" title="Open Address vs Separate Chaining"></a>Open Address vs Separate Chaining</h4><p>일단 두 방식 모두 Worst Case 에서 O(M)이다. 하지만 Open Address방식은 연속된 공간에 데이터를 저장하기 때문에 Separate Chaining에 비해 캐시 효율이 높다.<br>따라서 데이터의 개수가 충분히 적다면 Open Address방식이 Separate Chaining보다 더 성능이 좋다. 한 가지 차이점이 더 존재한다.<br>Separate Chaining방식에 비해 Open Address방식은 버킷을 계속해서 사용한다. 따라서 Separate Chaining 방식은 테이블의 확장을 보다 늦출 수 있다.</p>
<h4 id="보조-해시-함수"><a href="#보조-해시-함수" class="headerlink" title="보조 해시 함수"></a>보조 해시 함수</h4><p>보조 해시 함수(supplement hash function)의 목적은 key의 해시 값을 변형하여 해시 충돌 가능성을 줄이는 것이다.<br>Separate Chaining 방식을 사용할 때 함께 사용되며 보조 해시 함수로 Worst Case 에 가까워지는 경우를 줄일 수 있다.</p>
<h4 id="해시-버킷-동적-확장-Resize"><a href="#해시-버킷-동적-확장-Resize" class="headerlink" title="해시 버킷 동적 확장(Resize)"></a>해시 버킷 동적 확장(Resize)</h4><p>해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능 상 손실이 발생한다.<br>그래서 HashMap 은 key-value 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두 배로 늘린다.<br>이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다.<br>또 애매모호한 ‘일정 개수 이상’이라는 표현이 등장했다. 해시 버킷 크기를 두 배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. 0.75라는 숫자는 load factor 라고 불린다.</p>
<h3 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h3><p>정점과 간선의 집합, Graph<br>cf) 트리 또한 그래프이며, 그 중 사이클이 허용되지 않는 그래프를 말한다.</p>
<pre><code>--- 추후 추가 예정</code></pre></div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/취뽀가잣/">취뽀가잣!    </a></div><div class="post_share"><div class="social-share" data-image="/img/운영체제.PNG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/09/06/CS5/"><img class="prev_cover lozad" data-src="/img/운영체제.PNG" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>Technical Interview [면접후기]</span></div></a></div><div class="next-post pull-right"><a href="/2019/09/06/CS3/"><img class="next_cover lozad" data-src="/img/운영체제.PNG" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Technical Interview [네트워크]</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/09/06/CS1/" title="Technical Interview [개발상식]"><img class="relatedPosts_cover lozad" data-src="/img/운영체제.PNG"><div class="relatedPosts_title">Technical Interview [개발상식]</div></a></div><div class="relatedPosts_item"><a href="/2019/09/06/CS3/" title="Technical Interview [네트워크]"><img class="relatedPosts_cover lozad" data-src="/img/운영체제.PNG"><div class="relatedPosts_title">Technical Interview [네트워크]</div></a></div><div class="relatedPosts_item"><a href="/2019/09/06/CS5/" title="Technical Interview [면접후기]"><img class="relatedPosts_cover lozad" data-src="/img/운영체제.PNG"><div class="relatedPosts_title">Technical Interview [면접후기]</div></a></div><div class="relatedPosts_item"><a href="/2019/09/06/CS2/" title="Technical Interview [운영체제]"><img class="relatedPosts_cover lozad" data-src="/img/운영체제.PNG"><div class="relatedPosts_title">Technical Interview [운영체제]</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://khs9628.github.io/2019/09/06/CS4/';
  this.page.identifier = '2019/09/06/CS4/';
  this.page.title = 'Technical Interview [자료구조]';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'khs9628' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div></div><footer style="background-image: url(/img/운영체제.PNG)"><div id="footer"><div class="copyright">&copy;2019 - 2020 By 현수쓰</div><div class="footer_custom_text">Code Your Life</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="Dark Mode"></i></section><div class=" " id="post_bottom"><div id="post_bottom_items"><a id="mobile_to_comment" href="#post-comment"><i class="mobile_scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">Catalog</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#자료구조"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">자료구조</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Array-vs-LinkedList"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">Array vs LinkedList</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Stack-and-Queue"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">Stack and Queue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Tree"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">Tree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Binary-Heap"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">Binary Heap</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Red-Black-Tree"><span class="toc_mobile_items-number">1.1.4.</span> <span class="toc_mobile_items-text">Red Black Tree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#HashTable"><span class="toc_mobile_items-number">1.1.5.</span> <span class="toc_mobile_items-text">HashTable</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#hash-function"><span class="toc_mobile_items-number">1.1.5.1.</span> <span class="toc_mobile_items-text">hash function</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Resolve-Conflict"><span class="toc_mobile_items-number">1.1.5.2.</span> <span class="toc_mobile_items-text">Resolve Conflict</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#데이터가-적다는-것은-얼마나-적다는-것을-의미하는가"><span class="toc_mobile_items-number">1.1.5.3.</span> <span class="toc_mobile_items-text">데이터가 적다는 것은 얼마나 적다는 것을 의미하는가?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Open-Address-vs-Separate-Chaining"><span class="toc_mobile_items-number">1.1.5.4.</span> <span class="toc_mobile_items-text">Open Address vs Separate Chaining</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#보조-해시-함수"><span class="toc_mobile_items-number">1.1.5.5.</span> <span class="toc_mobile_items-text">보조 해시 함수</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#해시-버킷-동적-확장-Resize"><span class="toc_mobile_items-number">1.1.5.6.</span> <span class="toc_mobile_items-text">해시 버킷 동적 확장(Resize)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Graph"><span class="toc_mobile_items-number">1.1.6.</span> <span class="toc_mobile_items-text">Graph</span></a></li></ol></li></ol></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script color="0,0,255" opacity="0.7" zindex="-1" count="99" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/js/canvas-nest.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script></body></html>